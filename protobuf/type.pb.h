// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: type.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_type_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_type_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_type_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_type_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_type_2eproto;
namespace ntt {
class ComponentType;
class ComponentTypeDefaultTypeInternal;
extern ComponentTypeDefaultTypeInternal _ComponentType_default_instance_;
class Constraint;
class ConstraintDefaultTypeInternal;
extern ConstraintDefaultTypeInternal _Constraint_default_instance_;
class Constraint_Bounds;
class Constraint_BoundsDefaultTypeInternal;
extern Constraint_BoundsDefaultTypeInternal _Constraint_Bounds_default_instance_;
class EnumType;
class EnumTypeDefaultTypeInternal;
extern EnumTypeDefaultTypeInternal _EnumType_default_instance_;
class Field;
class FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class ListType;
class ListTypeDefaultTypeInternal;
extern ListTypeDefaultTypeInternal _ListType_default_instance_;
class PortType;
class PortTypeDefaultTypeInternal;
extern PortTypeDefaultTypeInternal _PortType_default_instance_;
class StringType;
class StringTypeDefaultTypeInternal;
extern StringTypeDefaultTypeInternal _StringType_default_instance_;
class StructType;
class StructTypeDefaultTypeInternal;
extern StructTypeDefaultTypeInternal _StructType_default_instance_;
class TimerType;
class TimerTypeDefaultTypeInternal;
extern TimerTypeDefaultTypeInternal _TimerType_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
}  // namespace ntt
PROTOBUF_NAMESPACE_OPEN
template<> ::ntt::ComponentType* Arena::CreateMaybeMessage<::ntt::ComponentType>(Arena*);
template<> ::ntt::Constraint* Arena::CreateMaybeMessage<::ntt::Constraint>(Arena*);
template<> ::ntt::Constraint_Bounds* Arena::CreateMaybeMessage<::ntt::Constraint_Bounds>(Arena*);
template<> ::ntt::EnumType* Arena::CreateMaybeMessage<::ntt::EnumType>(Arena*);
template<> ::ntt::Field* Arena::CreateMaybeMessage<::ntt::Field>(Arena*);
template<> ::ntt::ListType* Arena::CreateMaybeMessage<::ntt::ListType>(Arena*);
template<> ::ntt::PortType* Arena::CreateMaybeMessage<::ntt::PortType>(Arena*);
template<> ::ntt::StringType* Arena::CreateMaybeMessage<::ntt::StringType>(Arena*);
template<> ::ntt::StructType* Arena::CreateMaybeMessage<::ntt::StructType>(Arena*);
template<> ::ntt::TimerType* Arena::CreateMaybeMessage<::ntt::TimerType>(Arena*);
template<> ::ntt::Type* Arena::CreateMaybeMessage<::ntt::Type>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ntt {

enum ScalarType : int {
  NULL_ = 0,
  BOOLEAN = 1,
  FLOAT = 2,
  INTEGER = 3,
  VERDICT = 4,
  ScalarType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ScalarType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ScalarType_IsValid(int value);
constexpr ScalarType ScalarType_MIN = NULL_;
constexpr ScalarType ScalarType_MAX = VERDICT;
constexpr int ScalarType_ARRAYSIZE = ScalarType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScalarType_descriptor();
template<typename T>
inline const std::string& ScalarType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScalarType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScalarType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScalarType_descriptor(), enum_t_value);
}
inline bool ScalarType_Parse(
    const std::string& name, ScalarType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScalarType>(
    ScalarType_descriptor(), name, value);
}
// ===================================================================

class Type :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.Type) */ {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Type& default_instance();

  enum KindCase {
    kArray = 9,
    kRecordOf = 10,
    kSetOf = 11,
    kBitstring = 12,
    kCharstring = 13,
    kHextstring = 14,
    kOctetstring = 15,
    kUniversalCharstring = 16,
    kAnytype = 17,
    kRecord = 18,
    kSet = 19,
    kUnion = 20,
    kScalar = 21,
    kComponent = 22,
    kEnumerated = 23,
    kPort = 24,
    kTimer = 25,
    kAddress = 26,
    KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(nullptr);
  }

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.Type";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEncodeFieldNumber = 3,
    kVariantFieldNumber = 4,
    kExtensionFieldNumber = 5,
    kArrayFieldNumber = 9,
    kRecordOfFieldNumber = 10,
    kSetOfFieldNumber = 11,
    kBitstringFieldNumber = 12,
    kCharstringFieldNumber = 13,
    kHextstringFieldNumber = 14,
    kOctetstringFieldNumber = 15,
    kUniversalCharstringFieldNumber = 16,
    kAnytypeFieldNumber = 17,
    kRecordFieldNumber = 18,
    kSetFieldNumber = 19,
    kUnionFieldNumber = 20,
    kScalarFieldNumber = 21,
    kComponentFieldNumber = 22,
    kEnumeratedFieldNumber = 23,
    kPortFieldNumber = 24,
    kTimerFieldNumber = 25,
    kAddressFieldNumber = 26,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string encode = 3;
  void clear_encode();
  const std::string& encode() const;
  void set_encode(const std::string& value);
  void set_encode(std::string&& value);
  void set_encode(const char* value);
  void set_encode(const char* value, size_t size);
  std::string* mutable_encode();
  std::string* release_encode();
  void set_allocated_encode(std::string* encode);
  private:
  const std::string& _internal_encode() const;
  void _internal_set_encode(const std::string& value);
  std::string* _internal_mutable_encode();
  public:

  // string variant = 4;
  void clear_variant();
  const std::string& variant() const;
  void set_variant(const std::string& value);
  void set_variant(std::string&& value);
  void set_variant(const char* value);
  void set_variant(const char* value, size_t size);
  std::string* mutable_variant();
  std::string* release_variant();
  void set_allocated_variant(std::string* variant);
  private:
  const std::string& _internal_variant() const;
  void _internal_set_variant(const std::string& value);
  std::string* _internal_mutable_variant();
  public:

  // string extension = 5;
  void clear_extension();
  const std::string& extension() const;
  void set_extension(const std::string& value);
  void set_extension(std::string&& value);
  void set_extension(const char* value);
  void set_extension(const char* value, size_t size);
  std::string* mutable_extension();
  std::string* release_extension();
  void set_allocated_extension(std::string* extension);
  private:
  const std::string& _internal_extension() const;
  void _internal_set_extension(const std::string& value);
  std::string* _internal_mutable_extension();
  public:

  // .ntt.ListType array = 9;
  bool has_array() const;
  private:
  bool _internal_has_array() const;
  public:
  void clear_array();
  const ::ntt::ListType& array() const;
  ::ntt::ListType* release_array();
  ::ntt::ListType* mutable_array();
  void set_allocated_array(::ntt::ListType* array);
  private:
  const ::ntt::ListType& _internal_array() const;
  ::ntt::ListType* _internal_mutable_array();
  public:

  // .ntt.ListType record_of = 10;
  bool has_record_of() const;
  private:
  bool _internal_has_record_of() const;
  public:
  void clear_record_of();
  const ::ntt::ListType& record_of() const;
  ::ntt::ListType* release_record_of();
  ::ntt::ListType* mutable_record_of();
  void set_allocated_record_of(::ntt::ListType* record_of);
  private:
  const ::ntt::ListType& _internal_record_of() const;
  ::ntt::ListType* _internal_mutable_record_of();
  public:

  // .ntt.ListType set_of = 11;
  bool has_set_of() const;
  private:
  bool _internal_has_set_of() const;
  public:
  void clear_set_of();
  const ::ntt::ListType& set_of() const;
  ::ntt::ListType* release_set_of();
  ::ntt::ListType* mutable_set_of();
  void set_allocated_set_of(::ntt::ListType* set_of);
  private:
  const ::ntt::ListType& _internal_set_of() const;
  ::ntt::ListType* _internal_mutable_set_of();
  public:

  // .ntt.StringType bitstring = 12;
  bool has_bitstring() const;
  private:
  bool _internal_has_bitstring() const;
  public:
  void clear_bitstring();
  const ::ntt::StringType& bitstring() const;
  ::ntt::StringType* release_bitstring();
  ::ntt::StringType* mutable_bitstring();
  void set_allocated_bitstring(::ntt::StringType* bitstring);
  private:
  const ::ntt::StringType& _internal_bitstring() const;
  ::ntt::StringType* _internal_mutable_bitstring();
  public:

  // .ntt.StringType charstring = 13;
  bool has_charstring() const;
  private:
  bool _internal_has_charstring() const;
  public:
  void clear_charstring();
  const ::ntt::StringType& charstring() const;
  ::ntt::StringType* release_charstring();
  ::ntt::StringType* mutable_charstring();
  void set_allocated_charstring(::ntt::StringType* charstring);
  private:
  const ::ntt::StringType& _internal_charstring() const;
  ::ntt::StringType* _internal_mutable_charstring();
  public:

  // .ntt.StringType hextstring = 14;
  bool has_hextstring() const;
  private:
  bool _internal_has_hextstring() const;
  public:
  void clear_hextstring();
  const ::ntt::StringType& hextstring() const;
  ::ntt::StringType* release_hextstring();
  ::ntt::StringType* mutable_hextstring();
  void set_allocated_hextstring(::ntt::StringType* hextstring);
  private:
  const ::ntt::StringType& _internal_hextstring() const;
  ::ntt::StringType* _internal_mutable_hextstring();
  public:

  // .ntt.StringType octetstring = 15;
  bool has_octetstring() const;
  private:
  bool _internal_has_octetstring() const;
  public:
  void clear_octetstring();
  const ::ntt::StringType& octetstring() const;
  ::ntt::StringType* release_octetstring();
  ::ntt::StringType* mutable_octetstring();
  void set_allocated_octetstring(::ntt::StringType* octetstring);
  private:
  const ::ntt::StringType& _internal_octetstring() const;
  ::ntt::StringType* _internal_mutable_octetstring();
  public:

  // .ntt.StringType universal_charstring = 16;
  bool has_universal_charstring() const;
  private:
  bool _internal_has_universal_charstring() const;
  public:
  void clear_universal_charstring();
  const ::ntt::StringType& universal_charstring() const;
  ::ntt::StringType* release_universal_charstring();
  ::ntt::StringType* mutable_universal_charstring();
  void set_allocated_universal_charstring(::ntt::StringType* universal_charstring);
  private:
  const ::ntt::StringType& _internal_universal_charstring() const;
  ::ntt::StringType* _internal_mutable_universal_charstring();
  public:

  // .ntt.StructType anytype = 17;
  bool has_anytype() const;
  private:
  bool _internal_has_anytype() const;
  public:
  void clear_anytype();
  const ::ntt::StructType& anytype() const;
  ::ntt::StructType* release_anytype();
  ::ntt::StructType* mutable_anytype();
  void set_allocated_anytype(::ntt::StructType* anytype);
  private:
  const ::ntt::StructType& _internal_anytype() const;
  ::ntt::StructType* _internal_mutable_anytype();
  public:

  // .ntt.StructType record = 18;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::ntt::StructType& record() const;
  ::ntt::StructType* release_record();
  ::ntt::StructType* mutable_record();
  void set_allocated_record(::ntt::StructType* record);
  private:
  const ::ntt::StructType& _internal_record() const;
  ::ntt::StructType* _internal_mutable_record();
  public:

  // .ntt.StructType set = 19;
  bool has_set() const;
  private:
  bool _internal_has_set() const;
  public:
  void clear_set();
  const ::ntt::StructType& set() const;
  ::ntt::StructType* release_set();
  ::ntt::StructType* mutable_set();
  void set_allocated_set(::ntt::StructType* set);
  private:
  const ::ntt::StructType& _internal_set() const;
  ::ntt::StructType* _internal_mutable_set();
  public:

  // .ntt.StructType union = 20;
  bool has_union_() const;
  private:
  bool _internal_has_union_() const;
  public:
  void clear_union_();
  const ::ntt::StructType& union_() const;
  ::ntt::StructType* release_union_();
  ::ntt::StructType* mutable_union_();
  void set_allocated_union_(::ntt::StructType* union_);
  private:
  const ::ntt::StructType& _internal_union_() const;
  ::ntt::StructType* _internal_mutable_union_();
  public:

  // .ntt.ScalarType scalar = 21;
  private:
  bool _internal_has_scalar() const;
  public:
  void clear_scalar();
  ::ntt::ScalarType scalar() const;
  void set_scalar(::ntt::ScalarType value);
  private:
  ::ntt::ScalarType _internal_scalar() const;
  void _internal_set_scalar(::ntt::ScalarType value);
  public:

  // .ntt.ComponentType component = 22;
  bool has_component() const;
  private:
  bool _internal_has_component() const;
  public:
  void clear_component();
  const ::ntt::ComponentType& component() const;
  ::ntt::ComponentType* release_component();
  ::ntt::ComponentType* mutable_component();
  void set_allocated_component(::ntt::ComponentType* component);
  private:
  const ::ntt::ComponentType& _internal_component() const;
  ::ntt::ComponentType* _internal_mutable_component();
  public:

  // .ntt.EnumType enumerated = 23;
  bool has_enumerated() const;
  private:
  bool _internal_has_enumerated() const;
  public:
  void clear_enumerated();
  const ::ntt::EnumType& enumerated() const;
  ::ntt::EnumType* release_enumerated();
  ::ntt::EnumType* mutable_enumerated();
  void set_allocated_enumerated(::ntt::EnumType* enumerated);
  private:
  const ::ntt::EnumType& _internal_enumerated() const;
  ::ntt::EnumType* _internal_mutable_enumerated();
  public:

  // .ntt.PortType port = 24;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  const ::ntt::PortType& port() const;
  ::ntt::PortType* release_port();
  ::ntt::PortType* mutable_port();
  void set_allocated_port(::ntt::PortType* port);
  private:
  const ::ntt::PortType& _internal_port() const;
  ::ntt::PortType* _internal_mutable_port();
  public:

  // .ntt.TimerType timer = 25;
  bool has_timer() const;
  private:
  bool _internal_has_timer() const;
  public:
  void clear_timer();
  const ::ntt::TimerType& timer() const;
  ::ntt::TimerType* release_timer();
  ::ntt::TimerType* mutable_timer();
  void set_allocated_timer(::ntt::TimerType* timer);
  private:
  const ::ntt::TimerType& _internal_timer() const;
  ::ntt::TimerType* _internal_mutable_timer();
  public:

  // .ntt.Type address = 26;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const ::ntt::Type& address() const;
  ::ntt::Type* release_address();
  ::ntt::Type* mutable_address();
  void set_allocated_address(::ntt::Type* address);
  private:
  const ::ntt::Type& _internal_address() const;
  ::ntt::Type* _internal_mutable_address();
  public:

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:ntt.Type)
 private:
  class _Internal;
  void set_has_array();
  void set_has_record_of();
  void set_has_set_of();
  void set_has_bitstring();
  void set_has_charstring();
  void set_has_hextstring();
  void set_has_octetstring();
  void set_has_universal_charstring();
  void set_has_anytype();
  void set_has_record();
  void set_has_set();
  void set_has_union_();
  void set_has_scalar();
  void set_has_component();
  void set_has_enumerated();
  void set_has_port();
  void set_has_timer();
  void set_has_address();

  inline bool has_kind() const;
  inline void clear_has_kind();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variant_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_;
  union KindUnion {
    KindUnion() {}
    ::ntt::ListType* array_;
    ::ntt::ListType* record_of_;
    ::ntt::ListType* set_of_;
    ::ntt::StringType* bitstring_;
    ::ntt::StringType* charstring_;
    ::ntt::StringType* hextstring_;
    ::ntt::StringType* octetstring_;
    ::ntt::StringType* universal_charstring_;
    ::ntt::StructType* anytype_;
    ::ntt::StructType* record_;
    ::ntt::StructType* set_;
    ::ntt::StructType* union__;
    int scalar_;
    ::ntt::ComponentType* component_;
    ::ntt::EnumType* enumerated_;
    ::ntt::PortType* port_;
    ::ntt::TimerType* timer_;
    ::ntt::Type* address_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class Field :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.Field) */ {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Field* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const final {
    return CreateMaybeMessage<Field>(nullptr);
  }

  Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.Field";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ntt.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::ntt::Type& type() const;
  ::ntt::Type* release_type();
  ::ntt::Type* mutable_type();
  void set_allocated_type(::ntt::Type* type);
  private:
  const ::ntt::Type& _internal_type() const;
  ::ntt::Type* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:ntt.Field)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::ntt::Type* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class StructType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.StructType) */ {
 public:
  StructType();
  virtual ~StructType();

  StructType(const StructType& from);
  StructType(StructType&& from) noexcept
    : StructType() {
    *this = ::std::move(from);
  }

  inline StructType& operator=(const StructType& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructType& operator=(StructType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StructType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StructType* internal_default_instance() {
    return reinterpret_cast<const StructType*>(
               &_StructType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StructType& a, StructType& b) {
    a.Swap(&b);
  }
  inline void Swap(StructType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StructType* New() const final {
    return CreateMaybeMessage<StructType>(nullptr);
  }

  StructType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StructType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StructType& from);
  void MergeFrom(const StructType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.StructType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .ntt.Field fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::ntt::Field* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntt::Field >*
      mutable_fields();
  private:
  const ::ntt::Field& _internal_fields(int index) const;
  ::ntt::Field* _internal_add_fields();
  public:
  const ::ntt::Field& fields(int index) const;
  ::ntt::Field* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntt::Field >&
      fields() const;

  // @@protoc_insertion_point(class_scope:ntt.StructType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntt::Field > fields_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class ListType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.ListType) */ {
 public:
  ListType();
  virtual ~ListType();

  ListType(const ListType& from);
  ListType(ListType&& from) noexcept
    : ListType() {
    *this = ::std::move(from);
  }

  inline ListType& operator=(const ListType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListType& operator=(ListType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListType* internal_default_instance() {
    return reinterpret_cast<const ListType*>(
               &_ListType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListType& a, ListType& b) {
    a.Swap(&b);
  }
  inline void Swap(ListType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListType* New() const final {
    return CreateMaybeMessage<ListType>(nullptr);
  }

  ListType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListType& from);
  void MergeFrom(const ListType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.ListType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementFieldNumber = 1,
    kConstraintFieldNumber = 3,
  };
  // .ntt.Type element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::ntt::Type& element() const;
  ::ntt::Type* release_element();
  ::ntt::Type* mutable_element();
  void set_allocated_element(::ntt::Type* element);
  private:
  const ::ntt::Type& _internal_element() const;
  ::ntt::Type* _internal_mutable_element();
  public:

  // .ntt.Constraint constraint = 3;
  bool has_constraint() const;
  private:
  bool _internal_has_constraint() const;
  public:
  void clear_constraint();
  const ::ntt::Constraint& constraint() const;
  ::ntt::Constraint* release_constraint();
  ::ntt::Constraint* mutable_constraint();
  void set_allocated_constraint(::ntt::Constraint* constraint);
  private:
  const ::ntt::Constraint& _internal_constraint() const;
  ::ntt::Constraint* _internal_mutable_constraint();
  public:

  // @@protoc_insertion_point(class_scope:ntt.ListType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ntt::Type* element_;
  ::ntt::Constraint* constraint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class StringType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.StringType) */ {
 public:
  StringType();
  virtual ~StringType();

  StringType(const StringType& from);
  StringType(StringType&& from) noexcept
    : StringType() {
    *this = ::std::move(from);
  }

  inline StringType& operator=(const StringType& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringType& operator=(StringType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StringType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringType* internal_default_instance() {
    return reinterpret_cast<const StringType*>(
               &_StringType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StringType& a, StringType& b) {
    a.Swap(&b);
  }
  inline void Swap(StringType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringType* New() const final {
    return CreateMaybeMessage<StringType>(nullptr);
  }

  StringType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StringType& from);
  void MergeFrom(const StringType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.StringType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementWidthFieldNumber = 1,
  };
  // int32 element_width = 1;
  void clear_element_width();
  ::PROTOBUF_NAMESPACE_ID::int32 element_width() const;
  void set_element_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_element_width() const;
  void _internal_set_element_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ntt.StringType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 element_width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class Constraint_Bounds :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.Constraint.Bounds) */ {
 public:
  Constraint_Bounds();
  virtual ~Constraint_Bounds();

  Constraint_Bounds(const Constraint_Bounds& from);
  Constraint_Bounds(Constraint_Bounds&& from) noexcept
    : Constraint_Bounds() {
    *this = ::std::move(from);
  }

  inline Constraint_Bounds& operator=(const Constraint_Bounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraint_Bounds& operator=(Constraint_Bounds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Constraint_Bounds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Constraint_Bounds* internal_default_instance() {
    return reinterpret_cast<const Constraint_Bounds*>(
               &_Constraint_Bounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Constraint_Bounds& a, Constraint_Bounds& b) {
    a.Swap(&b);
  }
  inline void Swap(Constraint_Bounds* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Constraint_Bounds* New() const final {
    return CreateMaybeMessage<Constraint_Bounds>(nullptr);
  }

  Constraint_Bounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Constraint_Bounds>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Constraint_Bounds& from);
  void MergeFrom(const Constraint_Bounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constraint_Bounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.Constraint.Bounds";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // int64 start = 1;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int64 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 end = 2;
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int64 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:ntt.Constraint.Bounds)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class Constraint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.Constraint) */ {
 public:
  Constraint();
  virtual ~Constraint();

  Constraint(const Constraint& from);
  Constraint(Constraint&& from) noexcept
    : Constraint() {
    *this = ::std::move(from);
  }

  inline Constraint& operator=(const Constraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraint& operator=(Constraint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Constraint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Constraint* internal_default_instance() {
    return reinterpret_cast<const Constraint*>(
               &_Constraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Constraint& a, Constraint& b) {
    a.Swap(&b);
  }
  inline void Swap(Constraint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Constraint* New() const final {
    return CreateMaybeMessage<Constraint>(nullptr);
  }

  Constraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Constraint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Constraint& from);
  void MergeFrom(const Constraint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constraint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.Constraint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Constraint_Bounds Bounds;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ntt.Constraint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class ComponentType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.ComponentType) */ {
 public:
  ComponentType();
  virtual ~ComponentType();

  ComponentType(const ComponentType& from);
  ComponentType(ComponentType&& from) noexcept
    : ComponentType() {
    *this = ::std::move(from);
  }

  inline ComponentType& operator=(const ComponentType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComponentType& operator=(ComponentType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ComponentType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComponentType* internal_default_instance() {
    return reinterpret_cast<const ComponentType*>(
               &_ComponentType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ComponentType& a, ComponentType& b) {
    a.Swap(&b);
  }
  inline void Swap(ComponentType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComponentType* New() const final {
    return CreateMaybeMessage<ComponentType>(nullptr);
  }

  ComponentType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComponentType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ComponentType& from);
  void MergeFrom(const ComponentType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComponentType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.ComponentType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ntt.ComponentType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class EnumType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.EnumType) */ {
 public:
  EnumType();
  virtual ~EnumType();

  EnumType(const EnumType& from);
  EnumType(EnumType&& from) noexcept
    : EnumType() {
    *this = ::std::move(from);
  }

  inline EnumType& operator=(const EnumType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumType& operator=(EnumType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnumType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnumType* internal_default_instance() {
    return reinterpret_cast<const EnumType*>(
               &_EnumType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EnumType& a, EnumType& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnumType* New() const final {
    return CreateMaybeMessage<EnumType>(nullptr);
  }

  EnumType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnumType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnumType& from);
  void MergeFrom(const EnumType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.EnumType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ntt.EnumType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class PortType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.PortType) */ {
 public:
  PortType();
  virtual ~PortType();

  PortType(const PortType& from);
  PortType(PortType&& from) noexcept
    : PortType() {
    *this = ::std::move(from);
  }

  inline PortType& operator=(const PortType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortType& operator=(PortType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PortType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortType* internal_default_instance() {
    return reinterpret_cast<const PortType*>(
               &_PortType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PortType& a, PortType& b) {
    a.Swap(&b);
  }
  inline void Swap(PortType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortType* New() const final {
    return CreateMaybeMessage<PortType>(nullptr);
  }

  PortType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PortType& from);
  void MergeFrom(const PortType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.PortType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ntt.PortType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// -------------------------------------------------------------------

class TimerType :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ntt.TimerType) */ {
 public:
  TimerType();
  virtual ~TimerType();

  TimerType(const TimerType& from);
  TimerType(TimerType&& from) noexcept
    : TimerType() {
    *this = ::std::move(from);
  }

  inline TimerType& operator=(const TimerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimerType& operator=(TimerType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimerType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimerType* internal_default_instance() {
    return reinterpret_cast<const TimerType*>(
               &_TimerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TimerType& a, TimerType& b) {
    a.Swap(&b);
  }
  inline void Swap(TimerType* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimerType* New() const final {
    return CreateMaybeMessage<TimerType>(nullptr);
  }

  TimerType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimerType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimerType& from);
  void MergeFrom(const TimerType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimerType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntt.TimerType";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_type_2eproto);
    return ::descriptor_table_type_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ntt.TimerType)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_type_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Type

// string name = 1;
inline void Type::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:ntt.Type.name)
  return _internal_name();
}
inline void Type::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ntt.Type.name)
}
inline std::string* Type::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.name)
  return _internal_mutable_name();
}
inline const std::string& Type::_internal_name() const {
  return name_.GetNoArena();
}
inline void Type::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Type::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntt.Type.name)
}
inline void Type::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntt.Type.name)
}
inline void Type::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntt.Type.name)
}
inline std::string* Type::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Type::release_name() {
  // @@protoc_insertion_point(field_release:ntt.Type.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ntt.Type.name)
}

// string encode = 3;
inline void Type::clear_encode() {
  encode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Type::encode() const {
  // @@protoc_insertion_point(field_get:ntt.Type.encode)
  return _internal_encode();
}
inline void Type::set_encode(const std::string& value) {
  _internal_set_encode(value);
  // @@protoc_insertion_point(field_set:ntt.Type.encode)
}
inline std::string* Type::mutable_encode() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.encode)
  return _internal_mutable_encode();
}
inline const std::string& Type::_internal_encode() const {
  return encode_.GetNoArena();
}
inline void Type::_internal_set_encode(const std::string& value) {
  
  encode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Type::set_encode(std::string&& value) {
  
  encode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntt.Type.encode)
}
inline void Type::set_encode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  encode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntt.Type.encode)
}
inline void Type::set_encode(const char* value, size_t size) {
  
  encode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntt.Type.encode)
}
inline std::string* Type::_internal_mutable_encode() {
  
  return encode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Type::release_encode() {
  // @@protoc_insertion_point(field_release:ntt.Type.encode)
  
  return encode_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_encode(std::string* encode) {
  if (encode != nullptr) {
    
  } else {
    
  }
  encode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encode);
  // @@protoc_insertion_point(field_set_allocated:ntt.Type.encode)
}

// string variant = 4;
inline void Type::clear_variant() {
  variant_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Type::variant() const {
  // @@protoc_insertion_point(field_get:ntt.Type.variant)
  return _internal_variant();
}
inline void Type::set_variant(const std::string& value) {
  _internal_set_variant(value);
  // @@protoc_insertion_point(field_set:ntt.Type.variant)
}
inline std::string* Type::mutable_variant() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.variant)
  return _internal_mutable_variant();
}
inline const std::string& Type::_internal_variant() const {
  return variant_.GetNoArena();
}
inline void Type::_internal_set_variant(const std::string& value) {
  
  variant_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Type::set_variant(std::string&& value) {
  
  variant_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntt.Type.variant)
}
inline void Type::set_variant(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  variant_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntt.Type.variant)
}
inline void Type::set_variant(const char* value, size_t size) {
  
  variant_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntt.Type.variant)
}
inline std::string* Type::_internal_mutable_variant() {
  
  return variant_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Type::release_variant() {
  // @@protoc_insertion_point(field_release:ntt.Type.variant)
  
  return variant_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_variant(std::string* variant) {
  if (variant != nullptr) {
    
  } else {
    
  }
  variant_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), variant);
  // @@protoc_insertion_point(field_set_allocated:ntt.Type.variant)
}

// string extension = 5;
inline void Type::clear_extension() {
  extension_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Type::extension() const {
  // @@protoc_insertion_point(field_get:ntt.Type.extension)
  return _internal_extension();
}
inline void Type::set_extension(const std::string& value) {
  _internal_set_extension(value);
  // @@protoc_insertion_point(field_set:ntt.Type.extension)
}
inline std::string* Type::mutable_extension() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.extension)
  return _internal_mutable_extension();
}
inline const std::string& Type::_internal_extension() const {
  return extension_.GetNoArena();
}
inline void Type::_internal_set_extension(const std::string& value) {
  
  extension_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Type::set_extension(std::string&& value) {
  
  extension_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntt.Type.extension)
}
inline void Type::set_extension(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  extension_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntt.Type.extension)
}
inline void Type::set_extension(const char* value, size_t size) {
  
  extension_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntt.Type.extension)
}
inline std::string* Type::_internal_mutable_extension() {
  
  return extension_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Type::release_extension() {
  // @@protoc_insertion_point(field_release:ntt.Type.extension)
  
  return extension_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Type::set_allocated_extension(std::string* extension) {
  if (extension != nullptr) {
    
  } else {
    
  }
  extension_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extension);
  // @@protoc_insertion_point(field_set_allocated:ntt.Type.extension)
}

// .ntt.ListType array = 9;
inline bool Type::_internal_has_array() const {
  return kind_case() == kArray;
}
inline bool Type::has_array() const {
  return _internal_has_array();
}
inline void Type::set_has_array() {
  _oneof_case_[0] = kArray;
}
inline void Type::clear_array() {
  if (_internal_has_array()) {
    delete kind_.array_;
    clear_has_kind();
  }
}
inline ::ntt::ListType* Type::release_array() {
  // @@protoc_insertion_point(field_release:ntt.Type.array)
  if (_internal_has_array()) {
    clear_has_kind();
      ::ntt::ListType* temp = kind_.array_;
    kind_.array_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::ListType& Type::_internal_array() const {
  return _internal_has_array()
      ? *kind_.array_
      : *reinterpret_cast< ::ntt::ListType*>(&::ntt::_ListType_default_instance_);
}
inline const ::ntt::ListType& Type::array() const {
  // @@protoc_insertion_point(field_get:ntt.Type.array)
  return _internal_array();
}
inline ::ntt::ListType* Type::_internal_mutable_array() {
  if (!_internal_has_array()) {
    clear_kind();
    set_has_array();
    kind_.array_ = CreateMaybeMessage< ::ntt::ListType >(
        GetArenaNoVirtual());
  }
  return kind_.array_;
}
inline ::ntt::ListType* Type::mutable_array() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.array)
  return _internal_mutable_array();
}

// .ntt.ListType record_of = 10;
inline bool Type::_internal_has_record_of() const {
  return kind_case() == kRecordOf;
}
inline bool Type::has_record_of() const {
  return _internal_has_record_of();
}
inline void Type::set_has_record_of() {
  _oneof_case_[0] = kRecordOf;
}
inline void Type::clear_record_of() {
  if (_internal_has_record_of()) {
    delete kind_.record_of_;
    clear_has_kind();
  }
}
inline ::ntt::ListType* Type::release_record_of() {
  // @@protoc_insertion_point(field_release:ntt.Type.record_of)
  if (_internal_has_record_of()) {
    clear_has_kind();
      ::ntt::ListType* temp = kind_.record_of_;
    kind_.record_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::ListType& Type::_internal_record_of() const {
  return _internal_has_record_of()
      ? *kind_.record_of_
      : *reinterpret_cast< ::ntt::ListType*>(&::ntt::_ListType_default_instance_);
}
inline const ::ntt::ListType& Type::record_of() const {
  // @@protoc_insertion_point(field_get:ntt.Type.record_of)
  return _internal_record_of();
}
inline ::ntt::ListType* Type::_internal_mutable_record_of() {
  if (!_internal_has_record_of()) {
    clear_kind();
    set_has_record_of();
    kind_.record_of_ = CreateMaybeMessage< ::ntt::ListType >(
        GetArenaNoVirtual());
  }
  return kind_.record_of_;
}
inline ::ntt::ListType* Type::mutable_record_of() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.record_of)
  return _internal_mutable_record_of();
}

// .ntt.ListType set_of = 11;
inline bool Type::_internal_has_set_of() const {
  return kind_case() == kSetOf;
}
inline bool Type::has_set_of() const {
  return _internal_has_set_of();
}
inline void Type::set_has_set_of() {
  _oneof_case_[0] = kSetOf;
}
inline void Type::clear_set_of() {
  if (_internal_has_set_of()) {
    delete kind_.set_of_;
    clear_has_kind();
  }
}
inline ::ntt::ListType* Type::release_set_of() {
  // @@protoc_insertion_point(field_release:ntt.Type.set_of)
  if (_internal_has_set_of()) {
    clear_has_kind();
      ::ntt::ListType* temp = kind_.set_of_;
    kind_.set_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::ListType& Type::_internal_set_of() const {
  return _internal_has_set_of()
      ? *kind_.set_of_
      : *reinterpret_cast< ::ntt::ListType*>(&::ntt::_ListType_default_instance_);
}
inline const ::ntt::ListType& Type::set_of() const {
  // @@protoc_insertion_point(field_get:ntt.Type.set_of)
  return _internal_set_of();
}
inline ::ntt::ListType* Type::_internal_mutable_set_of() {
  if (!_internal_has_set_of()) {
    clear_kind();
    set_has_set_of();
    kind_.set_of_ = CreateMaybeMessage< ::ntt::ListType >(
        GetArenaNoVirtual());
  }
  return kind_.set_of_;
}
inline ::ntt::ListType* Type::mutable_set_of() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.set_of)
  return _internal_mutable_set_of();
}

// .ntt.StringType bitstring = 12;
inline bool Type::_internal_has_bitstring() const {
  return kind_case() == kBitstring;
}
inline bool Type::has_bitstring() const {
  return _internal_has_bitstring();
}
inline void Type::set_has_bitstring() {
  _oneof_case_[0] = kBitstring;
}
inline void Type::clear_bitstring() {
  if (_internal_has_bitstring()) {
    delete kind_.bitstring_;
    clear_has_kind();
  }
}
inline ::ntt::StringType* Type::release_bitstring() {
  // @@protoc_insertion_point(field_release:ntt.Type.bitstring)
  if (_internal_has_bitstring()) {
    clear_has_kind();
      ::ntt::StringType* temp = kind_.bitstring_;
    kind_.bitstring_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StringType& Type::_internal_bitstring() const {
  return _internal_has_bitstring()
      ? *kind_.bitstring_
      : *reinterpret_cast< ::ntt::StringType*>(&::ntt::_StringType_default_instance_);
}
inline const ::ntt::StringType& Type::bitstring() const {
  // @@protoc_insertion_point(field_get:ntt.Type.bitstring)
  return _internal_bitstring();
}
inline ::ntt::StringType* Type::_internal_mutable_bitstring() {
  if (!_internal_has_bitstring()) {
    clear_kind();
    set_has_bitstring();
    kind_.bitstring_ = CreateMaybeMessage< ::ntt::StringType >(
        GetArenaNoVirtual());
  }
  return kind_.bitstring_;
}
inline ::ntt::StringType* Type::mutable_bitstring() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.bitstring)
  return _internal_mutable_bitstring();
}

// .ntt.StringType charstring = 13;
inline bool Type::_internal_has_charstring() const {
  return kind_case() == kCharstring;
}
inline bool Type::has_charstring() const {
  return _internal_has_charstring();
}
inline void Type::set_has_charstring() {
  _oneof_case_[0] = kCharstring;
}
inline void Type::clear_charstring() {
  if (_internal_has_charstring()) {
    delete kind_.charstring_;
    clear_has_kind();
  }
}
inline ::ntt::StringType* Type::release_charstring() {
  // @@protoc_insertion_point(field_release:ntt.Type.charstring)
  if (_internal_has_charstring()) {
    clear_has_kind();
      ::ntt::StringType* temp = kind_.charstring_;
    kind_.charstring_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StringType& Type::_internal_charstring() const {
  return _internal_has_charstring()
      ? *kind_.charstring_
      : *reinterpret_cast< ::ntt::StringType*>(&::ntt::_StringType_default_instance_);
}
inline const ::ntt::StringType& Type::charstring() const {
  // @@protoc_insertion_point(field_get:ntt.Type.charstring)
  return _internal_charstring();
}
inline ::ntt::StringType* Type::_internal_mutable_charstring() {
  if (!_internal_has_charstring()) {
    clear_kind();
    set_has_charstring();
    kind_.charstring_ = CreateMaybeMessage< ::ntt::StringType >(
        GetArenaNoVirtual());
  }
  return kind_.charstring_;
}
inline ::ntt::StringType* Type::mutable_charstring() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.charstring)
  return _internal_mutable_charstring();
}

// .ntt.StringType hextstring = 14;
inline bool Type::_internal_has_hextstring() const {
  return kind_case() == kHextstring;
}
inline bool Type::has_hextstring() const {
  return _internal_has_hextstring();
}
inline void Type::set_has_hextstring() {
  _oneof_case_[0] = kHextstring;
}
inline void Type::clear_hextstring() {
  if (_internal_has_hextstring()) {
    delete kind_.hextstring_;
    clear_has_kind();
  }
}
inline ::ntt::StringType* Type::release_hextstring() {
  // @@protoc_insertion_point(field_release:ntt.Type.hextstring)
  if (_internal_has_hextstring()) {
    clear_has_kind();
      ::ntt::StringType* temp = kind_.hextstring_;
    kind_.hextstring_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StringType& Type::_internal_hextstring() const {
  return _internal_has_hextstring()
      ? *kind_.hextstring_
      : *reinterpret_cast< ::ntt::StringType*>(&::ntt::_StringType_default_instance_);
}
inline const ::ntt::StringType& Type::hextstring() const {
  // @@protoc_insertion_point(field_get:ntt.Type.hextstring)
  return _internal_hextstring();
}
inline ::ntt::StringType* Type::_internal_mutable_hextstring() {
  if (!_internal_has_hextstring()) {
    clear_kind();
    set_has_hextstring();
    kind_.hextstring_ = CreateMaybeMessage< ::ntt::StringType >(
        GetArenaNoVirtual());
  }
  return kind_.hextstring_;
}
inline ::ntt::StringType* Type::mutable_hextstring() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.hextstring)
  return _internal_mutable_hextstring();
}

// .ntt.StringType octetstring = 15;
inline bool Type::_internal_has_octetstring() const {
  return kind_case() == kOctetstring;
}
inline bool Type::has_octetstring() const {
  return _internal_has_octetstring();
}
inline void Type::set_has_octetstring() {
  _oneof_case_[0] = kOctetstring;
}
inline void Type::clear_octetstring() {
  if (_internal_has_octetstring()) {
    delete kind_.octetstring_;
    clear_has_kind();
  }
}
inline ::ntt::StringType* Type::release_octetstring() {
  // @@protoc_insertion_point(field_release:ntt.Type.octetstring)
  if (_internal_has_octetstring()) {
    clear_has_kind();
      ::ntt::StringType* temp = kind_.octetstring_;
    kind_.octetstring_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StringType& Type::_internal_octetstring() const {
  return _internal_has_octetstring()
      ? *kind_.octetstring_
      : *reinterpret_cast< ::ntt::StringType*>(&::ntt::_StringType_default_instance_);
}
inline const ::ntt::StringType& Type::octetstring() const {
  // @@protoc_insertion_point(field_get:ntt.Type.octetstring)
  return _internal_octetstring();
}
inline ::ntt::StringType* Type::_internal_mutable_octetstring() {
  if (!_internal_has_octetstring()) {
    clear_kind();
    set_has_octetstring();
    kind_.octetstring_ = CreateMaybeMessage< ::ntt::StringType >(
        GetArenaNoVirtual());
  }
  return kind_.octetstring_;
}
inline ::ntt::StringType* Type::mutable_octetstring() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.octetstring)
  return _internal_mutable_octetstring();
}

// .ntt.StringType universal_charstring = 16;
inline bool Type::_internal_has_universal_charstring() const {
  return kind_case() == kUniversalCharstring;
}
inline bool Type::has_universal_charstring() const {
  return _internal_has_universal_charstring();
}
inline void Type::set_has_universal_charstring() {
  _oneof_case_[0] = kUniversalCharstring;
}
inline void Type::clear_universal_charstring() {
  if (_internal_has_universal_charstring()) {
    delete kind_.universal_charstring_;
    clear_has_kind();
  }
}
inline ::ntt::StringType* Type::release_universal_charstring() {
  // @@protoc_insertion_point(field_release:ntt.Type.universal_charstring)
  if (_internal_has_universal_charstring()) {
    clear_has_kind();
      ::ntt::StringType* temp = kind_.universal_charstring_;
    kind_.universal_charstring_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StringType& Type::_internal_universal_charstring() const {
  return _internal_has_universal_charstring()
      ? *kind_.universal_charstring_
      : *reinterpret_cast< ::ntt::StringType*>(&::ntt::_StringType_default_instance_);
}
inline const ::ntt::StringType& Type::universal_charstring() const {
  // @@protoc_insertion_point(field_get:ntt.Type.universal_charstring)
  return _internal_universal_charstring();
}
inline ::ntt::StringType* Type::_internal_mutable_universal_charstring() {
  if (!_internal_has_universal_charstring()) {
    clear_kind();
    set_has_universal_charstring();
    kind_.universal_charstring_ = CreateMaybeMessage< ::ntt::StringType >(
        GetArenaNoVirtual());
  }
  return kind_.universal_charstring_;
}
inline ::ntt::StringType* Type::mutable_universal_charstring() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.universal_charstring)
  return _internal_mutable_universal_charstring();
}

// .ntt.StructType anytype = 17;
inline bool Type::_internal_has_anytype() const {
  return kind_case() == kAnytype;
}
inline bool Type::has_anytype() const {
  return _internal_has_anytype();
}
inline void Type::set_has_anytype() {
  _oneof_case_[0] = kAnytype;
}
inline void Type::clear_anytype() {
  if (_internal_has_anytype()) {
    delete kind_.anytype_;
    clear_has_kind();
  }
}
inline ::ntt::StructType* Type::release_anytype() {
  // @@protoc_insertion_point(field_release:ntt.Type.anytype)
  if (_internal_has_anytype()) {
    clear_has_kind();
      ::ntt::StructType* temp = kind_.anytype_;
    kind_.anytype_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StructType& Type::_internal_anytype() const {
  return _internal_has_anytype()
      ? *kind_.anytype_
      : *reinterpret_cast< ::ntt::StructType*>(&::ntt::_StructType_default_instance_);
}
inline const ::ntt::StructType& Type::anytype() const {
  // @@protoc_insertion_point(field_get:ntt.Type.anytype)
  return _internal_anytype();
}
inline ::ntt::StructType* Type::_internal_mutable_anytype() {
  if (!_internal_has_anytype()) {
    clear_kind();
    set_has_anytype();
    kind_.anytype_ = CreateMaybeMessage< ::ntt::StructType >(
        GetArenaNoVirtual());
  }
  return kind_.anytype_;
}
inline ::ntt::StructType* Type::mutable_anytype() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.anytype)
  return _internal_mutable_anytype();
}

// .ntt.StructType record = 18;
inline bool Type::_internal_has_record() const {
  return kind_case() == kRecord;
}
inline bool Type::has_record() const {
  return _internal_has_record();
}
inline void Type::set_has_record() {
  _oneof_case_[0] = kRecord;
}
inline void Type::clear_record() {
  if (_internal_has_record()) {
    delete kind_.record_;
    clear_has_kind();
  }
}
inline ::ntt::StructType* Type::release_record() {
  // @@protoc_insertion_point(field_release:ntt.Type.record)
  if (_internal_has_record()) {
    clear_has_kind();
      ::ntt::StructType* temp = kind_.record_;
    kind_.record_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StructType& Type::_internal_record() const {
  return _internal_has_record()
      ? *kind_.record_
      : *reinterpret_cast< ::ntt::StructType*>(&::ntt::_StructType_default_instance_);
}
inline const ::ntt::StructType& Type::record() const {
  // @@protoc_insertion_point(field_get:ntt.Type.record)
  return _internal_record();
}
inline ::ntt::StructType* Type::_internal_mutable_record() {
  if (!_internal_has_record()) {
    clear_kind();
    set_has_record();
    kind_.record_ = CreateMaybeMessage< ::ntt::StructType >(
        GetArenaNoVirtual());
  }
  return kind_.record_;
}
inline ::ntt::StructType* Type::mutable_record() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.record)
  return _internal_mutable_record();
}

// .ntt.StructType set = 19;
inline bool Type::_internal_has_set() const {
  return kind_case() == kSet;
}
inline bool Type::has_set() const {
  return _internal_has_set();
}
inline void Type::set_has_set() {
  _oneof_case_[0] = kSet;
}
inline void Type::clear_set() {
  if (_internal_has_set()) {
    delete kind_.set_;
    clear_has_kind();
  }
}
inline ::ntt::StructType* Type::release_set() {
  // @@protoc_insertion_point(field_release:ntt.Type.set)
  if (_internal_has_set()) {
    clear_has_kind();
      ::ntt::StructType* temp = kind_.set_;
    kind_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StructType& Type::_internal_set() const {
  return _internal_has_set()
      ? *kind_.set_
      : *reinterpret_cast< ::ntt::StructType*>(&::ntt::_StructType_default_instance_);
}
inline const ::ntt::StructType& Type::set() const {
  // @@protoc_insertion_point(field_get:ntt.Type.set)
  return _internal_set();
}
inline ::ntt::StructType* Type::_internal_mutable_set() {
  if (!_internal_has_set()) {
    clear_kind();
    set_has_set();
    kind_.set_ = CreateMaybeMessage< ::ntt::StructType >(
        GetArenaNoVirtual());
  }
  return kind_.set_;
}
inline ::ntt::StructType* Type::mutable_set() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.set)
  return _internal_mutable_set();
}

// .ntt.StructType union = 20;
inline bool Type::_internal_has_union_() const {
  return kind_case() == kUnion;
}
inline bool Type::has_union_() const {
  return _internal_has_union_();
}
inline void Type::set_has_union_() {
  _oneof_case_[0] = kUnion;
}
inline void Type::clear_union_() {
  if (_internal_has_union_()) {
    delete kind_.union__;
    clear_has_kind();
  }
}
inline ::ntt::StructType* Type::release_union_() {
  // @@protoc_insertion_point(field_release:ntt.Type.union)
  if (_internal_has_union_()) {
    clear_has_kind();
      ::ntt::StructType* temp = kind_.union__;
    kind_.union__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::StructType& Type::_internal_union_() const {
  return _internal_has_union_()
      ? *kind_.union__
      : *reinterpret_cast< ::ntt::StructType*>(&::ntt::_StructType_default_instance_);
}
inline const ::ntt::StructType& Type::union_() const {
  // @@protoc_insertion_point(field_get:ntt.Type.union)
  return _internal_union_();
}
inline ::ntt::StructType* Type::_internal_mutable_union_() {
  if (!_internal_has_union_()) {
    clear_kind();
    set_has_union_();
    kind_.union__ = CreateMaybeMessage< ::ntt::StructType >(
        GetArenaNoVirtual());
  }
  return kind_.union__;
}
inline ::ntt::StructType* Type::mutable_union_() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.union)
  return _internal_mutable_union_();
}

// .ntt.ScalarType scalar = 21;
inline bool Type::_internal_has_scalar() const {
  return kind_case() == kScalar;
}
inline void Type::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Type::clear_scalar() {
  if (_internal_has_scalar()) {
    kind_.scalar_ = 0;
    clear_has_kind();
  }
}
inline ::ntt::ScalarType Type::_internal_scalar() const {
  if (_internal_has_scalar()) {
    return static_cast< ::ntt::ScalarType >(kind_.scalar_);
  }
  return static_cast< ::ntt::ScalarType >(0);
}
inline ::ntt::ScalarType Type::scalar() const {
  // @@protoc_insertion_point(field_get:ntt.Type.scalar)
  return _internal_scalar();
}
inline void Type::_internal_set_scalar(::ntt::ScalarType value) {
  if (!_internal_has_scalar()) {
    clear_kind();
    set_has_scalar();
  }
  kind_.scalar_ = value;
}
inline void Type::set_scalar(::ntt::ScalarType value) {
  // @@protoc_insertion_point(field_set:ntt.Type.scalar)
  _internal_set_scalar(value);
}

// .ntt.ComponentType component = 22;
inline bool Type::_internal_has_component() const {
  return kind_case() == kComponent;
}
inline bool Type::has_component() const {
  return _internal_has_component();
}
inline void Type::set_has_component() {
  _oneof_case_[0] = kComponent;
}
inline void Type::clear_component() {
  if (_internal_has_component()) {
    delete kind_.component_;
    clear_has_kind();
  }
}
inline ::ntt::ComponentType* Type::release_component() {
  // @@protoc_insertion_point(field_release:ntt.Type.component)
  if (_internal_has_component()) {
    clear_has_kind();
      ::ntt::ComponentType* temp = kind_.component_;
    kind_.component_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::ComponentType& Type::_internal_component() const {
  return _internal_has_component()
      ? *kind_.component_
      : *reinterpret_cast< ::ntt::ComponentType*>(&::ntt::_ComponentType_default_instance_);
}
inline const ::ntt::ComponentType& Type::component() const {
  // @@protoc_insertion_point(field_get:ntt.Type.component)
  return _internal_component();
}
inline ::ntt::ComponentType* Type::_internal_mutable_component() {
  if (!_internal_has_component()) {
    clear_kind();
    set_has_component();
    kind_.component_ = CreateMaybeMessage< ::ntt::ComponentType >(
        GetArenaNoVirtual());
  }
  return kind_.component_;
}
inline ::ntt::ComponentType* Type::mutable_component() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.component)
  return _internal_mutable_component();
}

// .ntt.EnumType enumerated = 23;
inline bool Type::_internal_has_enumerated() const {
  return kind_case() == kEnumerated;
}
inline bool Type::has_enumerated() const {
  return _internal_has_enumerated();
}
inline void Type::set_has_enumerated() {
  _oneof_case_[0] = kEnumerated;
}
inline void Type::clear_enumerated() {
  if (_internal_has_enumerated()) {
    delete kind_.enumerated_;
    clear_has_kind();
  }
}
inline ::ntt::EnumType* Type::release_enumerated() {
  // @@protoc_insertion_point(field_release:ntt.Type.enumerated)
  if (_internal_has_enumerated()) {
    clear_has_kind();
      ::ntt::EnumType* temp = kind_.enumerated_;
    kind_.enumerated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::EnumType& Type::_internal_enumerated() const {
  return _internal_has_enumerated()
      ? *kind_.enumerated_
      : *reinterpret_cast< ::ntt::EnumType*>(&::ntt::_EnumType_default_instance_);
}
inline const ::ntt::EnumType& Type::enumerated() const {
  // @@protoc_insertion_point(field_get:ntt.Type.enumerated)
  return _internal_enumerated();
}
inline ::ntt::EnumType* Type::_internal_mutable_enumerated() {
  if (!_internal_has_enumerated()) {
    clear_kind();
    set_has_enumerated();
    kind_.enumerated_ = CreateMaybeMessage< ::ntt::EnumType >(
        GetArenaNoVirtual());
  }
  return kind_.enumerated_;
}
inline ::ntt::EnumType* Type::mutable_enumerated() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.enumerated)
  return _internal_mutable_enumerated();
}

// .ntt.PortType port = 24;
inline bool Type::_internal_has_port() const {
  return kind_case() == kPort;
}
inline bool Type::has_port() const {
  return _internal_has_port();
}
inline void Type::set_has_port() {
  _oneof_case_[0] = kPort;
}
inline void Type::clear_port() {
  if (_internal_has_port()) {
    delete kind_.port_;
    clear_has_kind();
  }
}
inline ::ntt::PortType* Type::release_port() {
  // @@protoc_insertion_point(field_release:ntt.Type.port)
  if (_internal_has_port()) {
    clear_has_kind();
      ::ntt::PortType* temp = kind_.port_;
    kind_.port_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::PortType& Type::_internal_port() const {
  return _internal_has_port()
      ? *kind_.port_
      : *reinterpret_cast< ::ntt::PortType*>(&::ntt::_PortType_default_instance_);
}
inline const ::ntt::PortType& Type::port() const {
  // @@protoc_insertion_point(field_get:ntt.Type.port)
  return _internal_port();
}
inline ::ntt::PortType* Type::_internal_mutable_port() {
  if (!_internal_has_port()) {
    clear_kind();
    set_has_port();
    kind_.port_ = CreateMaybeMessage< ::ntt::PortType >(
        GetArenaNoVirtual());
  }
  return kind_.port_;
}
inline ::ntt::PortType* Type::mutable_port() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.port)
  return _internal_mutable_port();
}

// .ntt.TimerType timer = 25;
inline bool Type::_internal_has_timer() const {
  return kind_case() == kTimer;
}
inline bool Type::has_timer() const {
  return _internal_has_timer();
}
inline void Type::set_has_timer() {
  _oneof_case_[0] = kTimer;
}
inline void Type::clear_timer() {
  if (_internal_has_timer()) {
    delete kind_.timer_;
    clear_has_kind();
  }
}
inline ::ntt::TimerType* Type::release_timer() {
  // @@protoc_insertion_point(field_release:ntt.Type.timer)
  if (_internal_has_timer()) {
    clear_has_kind();
      ::ntt::TimerType* temp = kind_.timer_;
    kind_.timer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::TimerType& Type::_internal_timer() const {
  return _internal_has_timer()
      ? *kind_.timer_
      : *reinterpret_cast< ::ntt::TimerType*>(&::ntt::_TimerType_default_instance_);
}
inline const ::ntt::TimerType& Type::timer() const {
  // @@protoc_insertion_point(field_get:ntt.Type.timer)
  return _internal_timer();
}
inline ::ntt::TimerType* Type::_internal_mutable_timer() {
  if (!_internal_has_timer()) {
    clear_kind();
    set_has_timer();
    kind_.timer_ = CreateMaybeMessage< ::ntt::TimerType >(
        GetArenaNoVirtual());
  }
  return kind_.timer_;
}
inline ::ntt::TimerType* Type::mutable_timer() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.timer)
  return _internal_mutable_timer();
}

// .ntt.Type address = 26;
inline bool Type::_internal_has_address() const {
  return kind_case() == kAddress;
}
inline bool Type::has_address() const {
  return _internal_has_address();
}
inline void Type::set_has_address() {
  _oneof_case_[0] = kAddress;
}
inline void Type::clear_address() {
  if (_internal_has_address()) {
    delete kind_.address_;
    clear_has_kind();
  }
}
inline ::ntt::Type* Type::release_address() {
  // @@protoc_insertion_point(field_release:ntt.Type.address)
  if (_internal_has_address()) {
    clear_has_kind();
      ::ntt::Type* temp = kind_.address_;
    kind_.address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ntt::Type& Type::_internal_address() const {
  return _internal_has_address()
      ? *kind_.address_
      : *reinterpret_cast< ::ntt::Type*>(&::ntt::_Type_default_instance_);
}
inline const ::ntt::Type& Type::address() const {
  // @@protoc_insertion_point(field_get:ntt.Type.address)
  return _internal_address();
}
inline ::ntt::Type* Type::_internal_mutable_address() {
  if (!_internal_has_address()) {
    clear_kind();
    set_has_address();
    kind_.address_ = CreateMaybeMessage< ::ntt::Type >(
        GetArenaNoVirtual());
  }
  return kind_.address_;
}
inline ::ntt::Type* Type::mutable_address() {
  // @@protoc_insertion_point(field_mutable:ntt.Type.address)
  return _internal_mutable_address();
}

inline bool Type::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Type::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline Type::KindCase Type::kind_case() const {
  return Type::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Field

// string name = 1;
inline void Field::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Field::name() const {
  // @@protoc_insertion_point(field_get:ntt.Field.name)
  return _internal_name();
}
inline void Field::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ntt.Field.name)
}
inline std::string* Field::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ntt.Field.name)
  return _internal_mutable_name();
}
inline const std::string& Field::_internal_name() const {
  return name_.GetNoArena();
}
inline void Field::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Field::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ntt.Field.name)
}
inline void Field::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ntt.Field.name)
}
inline void Field::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ntt.Field.name)
}
inline std::string* Field::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Field::release_name() {
  // @@protoc_insertion_point(field_release:ntt.Field.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ntt.Field.name)
}

// .ntt.Type type = 2;
inline bool Field::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Field::has_type() const {
  return _internal_has_type();
}
inline void Field::clear_type() {
  if (GetArenaNoVirtual() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::ntt::Type& Field::_internal_type() const {
  const ::ntt::Type* p = type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ntt::Type*>(
      &::ntt::_Type_default_instance_);
}
inline const ::ntt::Type& Field::type() const {
  // @@protoc_insertion_point(field_get:ntt.Field.type)
  return _internal_type();
}
inline ::ntt::Type* Field::release_type() {
  // @@protoc_insertion_point(field_release:ntt.Field.type)
  
  ::ntt::Type* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::ntt::Type* Field::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::ntt::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  return type_;
}
inline ::ntt::Type* Field::mutable_type() {
  // @@protoc_insertion_point(field_mutable:ntt.Field.type)
  return _internal_mutable_type();
}
inline void Field::set_allocated_type(::ntt::Type* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:ntt.Field.type)
}

// -------------------------------------------------------------------

// StructType

// repeated .ntt.Field fields = 1;
inline int StructType::_internal_fields_size() const {
  return fields_.size();
}
inline int StructType::fields_size() const {
  return _internal_fields_size();
}
inline void StructType::clear_fields() {
  fields_.Clear();
}
inline ::ntt::Field* StructType::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:ntt.StructType.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntt::Field >*
StructType::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:ntt.StructType.fields)
  return &fields_;
}
inline const ::ntt::Field& StructType::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::ntt::Field& StructType::fields(int index) const {
  // @@protoc_insertion_point(field_get:ntt.StructType.fields)
  return _internal_fields(index);
}
inline ::ntt::Field* StructType::_internal_add_fields() {
  return fields_.Add();
}
inline ::ntt::Field* StructType::add_fields() {
  // @@protoc_insertion_point(field_add:ntt.StructType.fields)
  return _internal_add_fields();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntt::Field >&
StructType::fields() const {
  // @@protoc_insertion_point(field_list:ntt.StructType.fields)
  return fields_;
}

// -------------------------------------------------------------------

// ListType

// .ntt.Type element = 1;
inline bool ListType::_internal_has_element() const {
  return this != internal_default_instance() && element_ != nullptr;
}
inline bool ListType::has_element() const {
  return _internal_has_element();
}
inline void ListType::clear_element() {
  if (GetArenaNoVirtual() == nullptr && element_ != nullptr) {
    delete element_;
  }
  element_ = nullptr;
}
inline const ::ntt::Type& ListType::_internal_element() const {
  const ::ntt::Type* p = element_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ntt::Type*>(
      &::ntt::_Type_default_instance_);
}
inline const ::ntt::Type& ListType::element() const {
  // @@protoc_insertion_point(field_get:ntt.ListType.element)
  return _internal_element();
}
inline ::ntt::Type* ListType::release_element() {
  // @@protoc_insertion_point(field_release:ntt.ListType.element)
  
  ::ntt::Type* temp = element_;
  element_ = nullptr;
  return temp;
}
inline ::ntt::Type* ListType::_internal_mutable_element() {
  
  if (element_ == nullptr) {
    auto* p = CreateMaybeMessage<::ntt::Type>(GetArenaNoVirtual());
    element_ = p;
  }
  return element_;
}
inline ::ntt::Type* ListType::mutable_element() {
  // @@protoc_insertion_point(field_mutable:ntt.ListType.element)
  return _internal_mutable_element();
}
inline void ListType::set_allocated_element(::ntt::Type* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete element_;
  }
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    
  } else {
    
  }
  element_ = element;
  // @@protoc_insertion_point(field_set_allocated:ntt.ListType.element)
}

// .ntt.Constraint constraint = 3;
inline bool ListType::_internal_has_constraint() const {
  return this != internal_default_instance() && constraint_ != nullptr;
}
inline bool ListType::has_constraint() const {
  return _internal_has_constraint();
}
inline void ListType::clear_constraint() {
  if (GetArenaNoVirtual() == nullptr && constraint_ != nullptr) {
    delete constraint_;
  }
  constraint_ = nullptr;
}
inline const ::ntt::Constraint& ListType::_internal_constraint() const {
  const ::ntt::Constraint* p = constraint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ntt::Constraint*>(
      &::ntt::_Constraint_default_instance_);
}
inline const ::ntt::Constraint& ListType::constraint() const {
  // @@protoc_insertion_point(field_get:ntt.ListType.constraint)
  return _internal_constraint();
}
inline ::ntt::Constraint* ListType::release_constraint() {
  // @@protoc_insertion_point(field_release:ntt.ListType.constraint)
  
  ::ntt::Constraint* temp = constraint_;
  constraint_ = nullptr;
  return temp;
}
inline ::ntt::Constraint* ListType::_internal_mutable_constraint() {
  
  if (constraint_ == nullptr) {
    auto* p = CreateMaybeMessage<::ntt::Constraint>(GetArenaNoVirtual());
    constraint_ = p;
  }
  return constraint_;
}
inline ::ntt::Constraint* ListType::mutable_constraint() {
  // @@protoc_insertion_point(field_mutable:ntt.ListType.constraint)
  return _internal_mutable_constraint();
}
inline void ListType::set_allocated_constraint(::ntt::Constraint* constraint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete constraint_;
  }
  if (constraint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      constraint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constraint, submessage_arena);
    }
    
  } else {
    
  }
  constraint_ = constraint;
  // @@protoc_insertion_point(field_set_allocated:ntt.ListType.constraint)
}

// -------------------------------------------------------------------

// StringType

// int32 element_width = 1;
inline void StringType::clear_element_width() {
  element_width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StringType::_internal_element_width() const {
  return element_width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StringType::element_width() const {
  // @@protoc_insertion_point(field_get:ntt.StringType.element_width)
  return _internal_element_width();
}
inline void StringType::_internal_set_element_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  element_width_ = value;
}
inline void StringType::set_element_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_element_width(value);
  // @@protoc_insertion_point(field_set:ntt.StringType.element_width)
}

// -------------------------------------------------------------------

// Constraint_Bounds

// int64 start = 1;
inline void Constraint_Bounds::clear_start() {
  start_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Constraint_Bounds::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Constraint_Bounds::start() const {
  // @@protoc_insertion_point(field_get:ntt.Constraint.Bounds.start)
  return _internal_start();
}
inline void Constraint_Bounds::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_ = value;
}
inline void Constraint_Bounds::set_start(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:ntt.Constraint.Bounds.start)
}

// int64 end = 2;
inline void Constraint_Bounds::clear_end() {
  end_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Constraint_Bounds::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Constraint_Bounds::end() const {
  // @@protoc_insertion_point(field_get:ntt.Constraint.Bounds.end)
  return _internal_end();
}
inline void Constraint_Bounds::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_ = value;
}
inline void Constraint_Bounds::set_end(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:ntt.Constraint.Bounds.end)
}

// -------------------------------------------------------------------

// Constraint

// -------------------------------------------------------------------

// ComponentType

// -------------------------------------------------------------------

// EnumType

// -------------------------------------------------------------------

// PortType

// -------------------------------------------------------------------

// TimerType

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ntt

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ntt::ScalarType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ntt::ScalarType>() {
  return ::ntt::ScalarType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_type_2eproto
